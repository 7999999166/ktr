"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const core_1 = __importDefault(require("@pwa-manifest/core"));
const posthtml_1 = __importDefault(require("posthtml"));
const logger_1 = __importDefault(require("@parcel/logger"));
const path_1 = require("path");
const fs_1 = require("fs");
const parcel_bundler_1 = require("parcel-bundler");
class PWAManifestAsset extends parcel_bundler_1.Asset {
    constructor(srcName, [fakePath, rootDir], outDir, trueContents) {
        super(fakePath, {
            outDir,
            rootDir
        });
        this.srcName = srcName;
        this.trueContents = trueContents;
        const noExt = srcName.slice(0, srcName.lastIndexOf('.'));
        this.hash = noExt.slice(noExt.lastIndexOf('.'));
        this.type = 'raw';
        this.generated = {
            raw: trueContents
        };
    }
    generateBundleName() {
        return this.srcName;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.trueContents instanceof Buffer
                ? this.trueContents
                : Buffer.from(this.trueContents);
        });
    }
}
module.exports = (bundler) => {
    let { outDir, publicURL, contentHash, target } = bundler.options;
    // istanbul ignore next
    if (target !== 'browser') {
        bundler.on('buildEnd', () => logger_1.default.warn("Manifest creation disabled: target is not 'browser'"));
        return;
    }
    // istanbul ignore next
    if (!publicURL)
        publicURL = '/';
    else if (!publicURL.endsWith('/'))
        publicURL += '/';
    bundler.on('buildStart', entryFiles => {
        try {
            let pkgDir = path_1.resolve(path_1.dirname(entryFiles[0]));
            // If root directory, dirname(pkgDir) === pkgDir
            while (!fs_1.existsSync(path_1.join(pkgDir, 'package.json'))) {
                // istanbul ignore next
                if (pkgDir === (pkgDir = path_1.dirname(pkgDir)))
                    throw 'No package.json found.';
            }
            const pkg = JSON.parse(fs_1.readFileSync(path_1.join(pkgDir, 'package.json')).toString());
            const opts = pkg.pwaManifest || pkg['pwa-manifest'];
            // istanbul ignore next
            if (typeof opts !== 'object') {
                if (typeof opts === 'undefined')
                    throw 'No PWA Manifest options found in package.json.';
                throw 'The PWA Manifest parameter in package.json must be an object containing the desired parameters.';
            }
            const generator = new core_1.default(opts, {
                baseURL: publicURL,
                resolveDir: pkgDir
            }, {
                name: pkg.name,
                desc: pkg.description
            });
            if (generator.disabled)
                return;
            generator.on('*', (ev, ...args) => {
                bundler.emit(`pwa${ev.slice(0, 1).toUpperCase() + ev.slice(1)}`, ...args);
                if (ev.endsWith('Start')) {
                    setTimeout(() => logger_1.default.progress(args[0]), 0);
                }
            });
            if (contentHash)
                generator.hashMethod = 'content';
            const createBundleTree = bundler.createBundleTree;
            const generationPromise = generator.generate();
            // Parcel, why can't you play nice?!
            bundler.createBundleTree = (arg0, bundle, ...args) => {
                bundler.createBundleTree = createBundleTree;
                bundler.createBundleTree(arg0, bundle, ...args);
                const bundlerPatch = generationPromise.then(({ html: pwaManifestInjection }) => {
                    const HTMLPackager = bundler.packagers.get('html');
                    class PWAManifestHTMLPackager extends HTMLPackager {
                        constructor() {
                            super(...arguments);
                            this.injectedPWAManifest = false;
                        }
                        addAsset(asset) {
                            return __awaiter(this, void 0, void 0, function* () {
                                // Copied mostly from Parcel source code
                                let html = asset.generated.html || '';
                                const siblingBundles = Array.from(this.bundle.childBundles)
                                    .reduce((p, b) => p.concat([...b.siblingBundles.values()]), [])
                                    .filter((b) => b.type === 'css' || b.type === 'js');
                                html = posthtml_1.default([
                                    tree => {
                                        if (this.injectedPWAManifest)
                                            return;
                                        this.injectedPWAManifest = true;
                                        tree.match({ tag: 'head' }, node => {
                                            node.content.push(...pwaManifestInjection.map(([tag, attrs]) => {
                                                return {
                                                    tag,
                                                    attrs
                                                }; // suppress stupid TypeScript errors
                                            }));
                                            return node;
                                        });
                                    },
                                    this.insertSiblingBundles.bind(this, siblingBundles)
                                ]).process(html, { sync: true }).html;
                                yield this.write(html);
                            });
                        }
                    }
                    bundler.packagers.add('html', PWAManifestHTMLPackager);
                });
                let addedAssets = false;
                const { name: fakePath, options: { rootDir } } = (bundle.entryAsset
                    ? bundle
                    : bundle.childBundles.values().next()
                        .value).entryAsset;
                const modBundle = (localBundle) => {
                    const _package = localBundle._package;
                    const packageFn = localBundle.package;
                    localBundle.package = (...args) => __awaiter(void 0, void 0, void 0, function* () {
                        const { manifest, browserConfig, generatedFiles } = yield generationPromise;
                        if (!addedAssets) {
                            addedAssets = true;
                            localBundle.createChildBundle(new PWAManifestAsset('manifest.webmanifest', [fakePath, rootDir], outDir, JSON.stringify(manifest)));
                            localBundle.createChildBundle(new PWAManifestAsset('browserconfig.xml', [fakePath, rootDir], outDir, browserConfig));
                            for (const file in generatedFiles)
                                localBundle.createChildBundle(new PWAManifestAsset(file, [fakePath, rootDir], outDir, generatedFiles[file]));
                            logger_1.default.success('Manifest creation successful.');
                        }
                        localBundle.package = packageFn;
                        return yield localBundle.package(...args);
                    });
                    localBundle._package = () => __awaiter(void 0, void 0, void 0, function* () {
                        yield bundlerPatch;
                        localBundle._package = _package;
                        yield localBundle._package(bundler);
                    });
                    for (const childBundle of localBundle.childBundles.values())
                        modBundle(childBundle);
                };
                modBundle(bundle);
            };
        }
        catch (msg) /* istanbul ignore next */ {
            logger_1.default.clear();
            logger_1.default.error('Manifest creation failed! ' + msg);
        }
    });
};
